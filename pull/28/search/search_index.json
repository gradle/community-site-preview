{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Gradle Cookbook","text":"<p>Hello, world!</p>"},{"location":"CONTRIBUTING/","title":"Contributing","text":""},{"location":"CONTRIBUTING/#contributing-to-the-gradle-cookbook","title":"Contributing to the Gradle Cookbook","text":"<p>The Gradle Cookbook is under active development. Any contributions are welcome!</p>"},{"location":"CONTRIBUTING/#discuss","title":"Discuss","text":"<ul> <li><code>#docs</code> on the Gradle Community Slack</li> <li>GitHub Issues</li> </ul>"},{"location":"CONTRIBUTING/#development-environment","title":"Development Environment","text":"<p>Follow this documentation for the community site.</p>"},{"location":"CONTRIBUTING/#howtos","title":"HOWTOs","text":""},{"location":"CONTRIBUTING/#editing-and-adding-pages","title":"Editing and Adding Pages","text":"<p>A few tips:</p> <ul> <li>All the pages on this site are written in Markdown.</li> <li>If needed, we have various tools available, such as code templates and macros, and we can add more MkDocs plugins if necessary.</li> <li>The Table of Contents is currently located in mkdocs.yml. When adding new pages, please update the ToC to ensure they are discoverable.</li> </ul>"},{"location":"CONTRIBUTING/#adding-new-categories","title":"Adding New Categories","text":"<p>At the moment, we add categories based on consensus. If you plan to add a new major category, it's better to discuss it in advance.</p>"},{"location":"CONTRIBUTING/#previews","title":"Previews","text":"<p>For any pull equest with the approved GitHub Actions run, a preview site will be deployed. The build both will share the link in the comments to the pull request.</p>"},{"location":"CONTRIBUTING/#references","title":"References","text":"<ul> <li>Main Contributor Guide - describes how to contribute to Gradle</li> </ul>"},{"location":"chapters/","title":"Gradle Cookbook Chapters","text":"<p>Below, you can see the list of the chapters that are currently available on the cookbook. More chapters will be added soon, based on contributions.</p>"},{"location":"chapters/#by-technology","title":"By Technology","text":"<ul> <li>Gradle for Kotlin development</li> <li>Gradle for Android development</li> <li>Gradle on Continuous Integration</li> </ul>"},{"location":"chapters/#for-developers","title":"For Developers","text":"<ul> <li>Troubleshooting Gradle issues and performance</li> <li>Plugin Development</li> </ul>"},{"location":"preface/","title":"The Gradle Cookbook","text":"<p>Gradle Cookbook is an open-source collection of recipes, guides and examples for the Gradle Build Tool. This is a complementary resource to the official Gradle User Manual, which covers core capabilities maintained by the Gradle team.</p> <p>The goal of this portal is to offer solution-based documentation for end users about external integrations, including but not limited to  CI/CD tools, IDEs, support for languages and frameworks, and various peripheral tools.</p> <p>In the Gradle Cookbook, Gradle Build Tool is abbreviated Gradle.</p> <p>Note</p> <p>The Gradle Cookbook is under active development (see the roadmap item here). Its structure, scope and links may change, and we're working on adding more content. Any contributions are welcome, see the Contributor Guide!</p>"},{"location":"preface/#why-and-how","title":"Why and How?","text":"<p>The Gradle Build Tool ecosystem is huge, it includes many plugins, integrations, developer tools and other components. Not all of them can be covered in the Gradle User Manual which represents core documentation maintained for each Gradle release. Moreover, being tied to the Gradle release contribution process and the release cycle makes it more difficult to contribute there. Maintaining documentation has been challenging for us as well, leading to many outdated pages.</p> <p>So, we decided to build a second resource as an extension to the Gradle User Manual, with the following in mind:</p> <ul> <li>Gradle Cookbook remains an official resource under <code>community.gradle.org</code>.   It is not a second-class citizen, just another structure that is not tied to the Gradle release cycle</li> <li>Pages should be focused on offering solutions to end users for particular use cases,   hence the Cookbook</li> <li>We follow the Wiki-alike collaboration style,   with a lower barrier to contribute than <code>gradle/gradle</code>.   Some sections can get explicit maintainers/reviewers over time.</li> <li>We use Documentation-as-Code, with simple Markdown or Asciidoc files used as a source</li> <li>Minimizing duplication.   We can include documentation from other sources under the Gradle GitHub organization</li> </ul>"},{"location":"preface/#trademark-notice","title":"Trademark Notice","text":"<p>Gradle and the Gradlephant logo (the \"Gradle Marks\") are registered trademarks of Gradle, Inc. and/or its subsidiaries. Use of the Gradle Marks the Gradle Cookbook pages is for identification purposes only and does not imply sponsorship or endorsement by Gradle, Inc. In the Gradle Cookbook, \"Gradle\" typically means \"Gradle Build Tool\" and does not reference Gradle Inc. and/or its subsidiaries.</p> <p>See the Gradle Branding Guidelines for more information about trademark usage and the approval process.</p>"},{"location":"preface/#references","title":"References","text":"<ul> <li>Gradle User Manual</li> <li>Other Documentation Locations</li> </ul>"},{"location":"android/","title":"Gradle for Android","text":""},{"location":"android/#gradle-for-android","title":"Gradle for Android","text":"<p>Gradle is one of the most popular build tools in the Android ecosystem. It is used for Kotlin and Kotlin Multiplatform, Flutter, React Native, and other toolchains.</p>"},{"location":"android/#official-documentation","title":"Official Documentation","text":"<p>The official documentation for Android development with Gradle is provided by Google and the community on the Android Developers site. You can find this documentation here.</p>"},{"location":"android/#featured-recipes","title":"Featured Recipes","text":"<ul> <li> <p>Gradle build overview - Understand how Gradle builds Android applications with Gradle using Android Gradle Plugin (AGP), key concepts, and the structure of a standard Android project.</p> </li> <li> <p>Android build management - Configure your Android builds for better packaging to test, build, sign, and distribute your app bundles and APKs.</p> </li> <li> <p>Managing dependencies - Configure remote repositories to add external binaries or other library modules into your build as dependencies.</p> </li> <li> <p>Building project - Execute tasks available for Android projects using the Gradle wrapper to build and deploy APKs and app bundles.</p> </li> <li> <p>Optimizing Builds - Configure your builds to decrease the build time, resulting in faster development of your Android projects.</p> </li> <li> <p>Extending AGP - AGP contains extension points for plugins to control build inputs and extend its functionality through new steps that can be integrated with standard build tasks.</p> </li> <li> <p>Migration Guide - Guide for migrating from Groovy to Kotlin DSL, version catalogs, Kapt (Kotlin Annotation Processing Tool) to KSP (Kotlin Symbol Processing).</p> </li> <li> <p>Troubleshooting AGP - Troubleshooting guide if you encounter issues with the Android Gradle Plugin (AGP).</p> </li> </ul>"},{"location":"android/#expanded-sections","title":"Expanded Sections","text":""},{"location":"android/#1-gradle-build-overview","title":"1. Gradle Build Overview","text":"<p>Gradle builds Android applications using the Android Gradle Plugin (AGP), which provides the flexibility to define build types, product flavors, and dependencies. Understanding these key concepts is crucial for creating efficient and scalable Android projects.</p>"},{"location":"android/#key-concepts","title":"Key Concepts:","text":"<ul> <li>Build Variants: Manage multiple variants of your app such as <code>debug</code> and <code>release</code>.</li> <li>Build Types: Use predefined types (e.g., <code>debug</code>, <code>release</code>) to control various build configurations.</li> <li>Kotlin DSL: Gradle uses Kotlin DSL by default for better type safety and editor support in Android builds.</li> </ul>"},{"location":"android/#example-in-kotlin-dsl","title":"Example in Kotlin DSL:","text":"<pre><code>android {\n    buildTypes {\n        release {\n            minifyEnabled(true)\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n}\n</code></pre> For more details, visit the Gradle build overview."},{"location":"android/#2-android-build-management","title":"2. Android Build Management","text":"<p>Android build management allows you to define various configurations for packaging, testing, signing, and distributing your app. The ability to manage product flavors, build types, and dynamic delivery modules ensures flexibility across different versions of your app.</p>"},{"location":"android/#example-of-build-flavors","title":"Example of Build Flavors:","text":"<pre><code>android {\n    flavorDimensions(\"version\")\n    productFlavors {\n        free {\n            dimension = \"version\"\n        }\n        paid {\n            dimension = \"version\"\n        }\n    }\n}\n</code></pre> For more information, visit Android build management."},{"location":"android/#3-managing-dependencies","title":"3. Managing Dependencies","text":"<p>Gradle enables the addition of external binaries or library modules as dependencies, which is essential for maintaining large Android projects. You can also use version catalogs to resolve dependency version conflicts and handle dependencies in Kotlin Multiplatform projects.</p>"},{"location":"android/#example-of-dependencies-in-kotlin-dsl","title":"Example of Dependencies in Kotlin DSL:","text":"<pre><code>dependencies {\n    implementation(\"com.squareup.retrofit2:retrofit:2.9.0\")\n    implementation(platform(\"com.google.firebase:firebase-bom:26.7.0\"))\n}\n</code></pre> For more information, visit Managing dependencies."},{"location":"android/#4-building-projects","title":"4. Building Projects","text":"<p>Gradle provides tasks for building your Android projects, including compiling code, packaging APKs, and generating app bundles. Using the Gradle wrapper, you can ensure build consistency across environments.</p>"},{"location":"android/#example-of-building-an-apk-with-kotlin-dsl","title":"Example of Building an APK with Kotlin DSL:","text":"<pre><code>tasks.register(\"customAssembleDebug\") {\n    doLast {\n        println(\"Building APK in debug mode...\")\n    }\n}\n</code></pre> This Kotlin example registers a task to build the APK in debug mode. For more detailed steps on building projects and packaging apps, visit the Building Projects Guide."},{"location":"android/#5-optimizing-builds","title":"5. Optimizing Builds","text":"<p>Gradle provides various options to improve build performance, including build caching, parallel execution, and Gradle Daemon tuning. These methods are especially beneficial for larger projects, helping to reduce build times and enhance productivity.</p>"},{"location":"android/#example-of-enabling-parallel-execution","title":"Example of Enabling Parallel Execution:","text":"<pre><code>org.gradle.parallel=true\n</code></pre> <p>To explore more optimization techniques and configure your builds for better performance, check out our detailed guide: Gradle Build Optimization. </p> <p>For further information, visit the official Optimizing Builds Guide.</p>"},{"location":"android/#6-extending-agp","title":"6. Extending AGP","text":"<p>You can extend the Android Gradle Plugin (AGP) by writing custom tasks and plugins to integrate new functionality into the existing build system. This allows for advanced customization and flexibility in your build processes.</p>"},{"location":"android/#example-of-a-custom-task","title":"Example of a Custom Task:","text":"<pre><code>tasks.register(\"printHelloMessage\") {\n    doLast {\n        println(\"Hello, Android Developers!\")\n    }\n}\n</code></pre> For more information, visit Extending AGP."},{"location":"android/#7-migration-guide","title":"7. Migration Guide","text":"<p>With the shift from Groovy to Kotlin DSL in the Android ecosystem, migrating your build scripts is essential. This guide helps you transition your build configurations and annotation processing from Kapt to KSP.</p> <p>For detailed steps and best practices, refer to the official Migration Guide.</p>"},{"location":"android/#8-troubleshooting-agp","title":"8. Troubleshooting AGP","text":"<p>Encountering issues with the Android Gradle Plugin (AGP) is common, and this section provides solutions to common problems such as dependency resolution failures, build script errors, and performance bottlenecks.</p>"},{"location":"android/#example-of-dependency-conflict-resolution","title":"Example of Dependency Conflict Resolution:","text":"<pre><code>configurations.all {\n    resolutionStrategy {\n        force(\"com.google.guava:guava:27.0.1-android\")\n    }\n}\n</code></pre> For more troubleshooting tips, visit the official Troubleshooting AGP page. <p>You can also check the Gradle Troubleshooting page for additional help with Gradle-specific issues.</p>"},{"location":"android/#references","title":"References","text":"<ul> <li>Official Documentation</li> <li>AGP releases</li> <li>Android Gradle Plugin API reference</li> </ul>"},{"location":"android/optimization/","title":"Gradle Build Optimization","text":""},{"location":"android/optimization/#gradle-build-optimization","title":"Gradle Build Optimization","text":"<p>This page references key external resources to help you optimize your Android Gradle builds. Below are some techniques and guides:</p> <ul> <li>Build Caching \u2013 Reduce unnecessary tasks by reusing outputs from previous builds.</li> <li>Parallel Execution \u2013 Execute independent tasks in parallel to speed up the build.</li> <li>Gradle Daemon \u2013 Optimize build performance by using a persistent process for faster execution.</li> </ul> <p>More original content will be added soon to cover performance monitoring, advanced caching strategies, and Gradle tuning specific to large-scale projects.</p>"},{"location":"android/troubleshooting/","title":"Troubleshooting Android Gradle Plugin (AGP)","text":""},{"location":"android/troubleshooting/#troubleshooting-android-gradle-plugin-agp","title":"Troubleshooting Android Gradle Plugin (AGP)","text":"<p>This page serves as a resource for resolving common issues encountered while working with the Android Gradle Plugin (AGP). Below are some typical problems and solutions.</p>"},{"location":"android/troubleshooting/#common-issues","title":"Common Issues","text":""},{"location":"android/troubleshooting/#1-dependency-resolution-failures","title":"1. Dependency Resolution Failures","text":"<p>Dependency conflicts can arise when multiple libraries require different versions of the same dependency. Use the following example to enforce a specific version:</p> <pre><code>configurations.all {\n    resolutionStrategy {\n        force(\"com.google.guava:guava:27.0.1-android\")\n    }\n}\n</code></pre>"},{"location":"android/troubleshooting/#2-build-script-errors","title":"2. Build Script Errors","text":"<p>Errors in the build script can prevent the project from compiling. Ensure that all plugins and dependencies are correctly defined. Review the logs for specific error messages that can guide you to the problem.</p>"},{"location":"android/troubleshooting/#3-performance-bottlenecks","title":"3. Performance Bottlenecks","text":"<p>Build performance issues may occur due to improper configurations. To optimize your build time, consider using techniques like enabling build caching and parallel execution.</p>"},{"location":"android/troubleshooting/#additional-resources","title":"Additional Resources","text":"<ul> <li>Troubleshooting AGP page.</li> </ul>"},{"location":"android/troubleshooting/#contributing","title":"Contributing","text":"<p>Feel free to add additional tips or common issues you encounter. Contributions are welcome to improve this troubleshooting guide.</p>"},{"location":"ci/","title":"Summary","text":""},{"location":"ci/#using-gradle-with-continuous-integration-systems","title":"Using Gradle with Continuous Integration Systems","text":"<p>Gradle has many integrations with Continuous Integration (CI) and Continuous Delivery (CD) systems. Below you can find references to integrations and best practices.</p> <p>Warning</p> <p>This section is under active development. The pages might be outdated, contributions are welcome!</p>"},{"location":"ci/#recipes","title":"Recipes","text":"<ul> <li>GitHub Actions</li> <li>GitLab CI</li> <li>Jenkins</li> <li>TeamCity</li> <li>Travis CI</li> </ul>"},{"location":"ci/#external-pages","title":"External Pages","text":"<ul> <li>Tekton task for Gradle</li> <li>CircleCI orb for Gradle</li> </ul>"},{"location":"ci/github-actions/","title":"GitHub Actions","text":""},{"location":"ci/github-actions/#executing-gradle-builds-on-github-actions","title":"Executing Gradle builds on GitHub Actions","text":"<p>Tip</p> <p>Top engineering teams using GitHub Actions have been able to reduce CI build time by up to 90% by using the Gradle Build Cache. Register here for our Build Cache training session to learn how your team can achieve similar results.</p> <p>Building Gradle projects doesn't stop with the developer's machine. Continuous Integration (CI) has been a long-established practice for running a build for every single change committed to version control to tighten the feedback loop.</p> <p>In this guide, we'll discuss how to configure GitHub Actions for a Gradle project hosted on GitHub.</p>"},{"location":"ci/github-actions/#introduction","title":"Introduction","text":"<p>GitHub Actions is a cloud-based CI solution provider built directly into GitHub, making it an excellent choice for projects hosted on GitHub. Using the setup-gradle GitHub Action makes it simple to integrate any Gradle project into a GitHub Actions workflow.</p>"},{"location":"ci/github-actions/#what-youll-need","title":"What you'll need","text":"<ul> <li>A text editor</li> <li>A command prompt</li> <li>The Java Development Kit (JDK), version 1.8 or higher</li> <li>A local Gradle installation, to initialize a new Gradle project</li> <li>A GitHub account</li> </ul>"},{"location":"ci/github-actions/#setup-a-gradle-project-on-github","title":"Setup a Gradle project on GitHub","text":"<p>If you have an existing Gradle project hosted on GitHub, then you can skip this step and move directly to Configure GitHub Actions.</p> <p>If not, follow these steps to initialize a new Gradle project on GitHub.</p>"},{"location":"ci/github-actions/#create-a-new-github-repository-for-your-project","title":"Create a new GitHub repository for your project","text":"<p>Via the GitHub user interface, create a new repository named <code>github-actions-gradle-sample</code>.</p> <p></p>"},{"location":"ci/github-actions/#clone-the-repository-locally","title":"Clone the repository locally","text":"<pre><code>$ git clone git@github.com:&lt;YOUR-GITHUB-USER&gt;/github-actions-gradle-sample.git\nCloning into 'github-actions-gradle-sample'...\n$ cd github-actions-gradle-sample\n</code></pre>"},{"location":"ci/github-actions/#initialize-the-gradle-project-and-commit-to-the-repository","title":"Initialize the Gradle project and commit to the repository","text":"<p>Use <code>gradle init</code> to create a fresh Gradle project. You can choose any of the available options during <code>init</code>, but we recommend choosing \"library\" as the project type.</p> <p>Once the project is generated, commit the changes and push to the repository.</p> <pre><code>$ gradle init\n$ git add .\n$ git commit -m \"Initial commit\"\n$ git push\n</code></pre>"},{"location":"ci/github-actions/#test-building-the-project","title":"Test building the project","text":"<p>The project uses the Gradle Wrapper for building the project. It is a recommended practice for any Gradle project as it enables your project to be built on CI without having to install the Gradle runtime.</p> <p>Before asking GitHub Actions to build your project, it's useful to ensure that it builds locally. Adding the \"CI\" environment variable will emulate running the build on GitHub Actions.</p> <p>The following command achieves that:</p> <pre><code>$ CI=true ./gradlew build\n\nBUILD SUCCESSFUL\n</code></pre> <p>If the build works as expected, we are ready to build it with GitHub Actions.</p>"},{"location":"ci/github-actions/#configure-github-actions","title":"Configure GitHub Actions","text":"<p>You can create a GitHub Actions workflow by adding a <code>.github/workflows/&lt;workflow-name&gt;.yml</code> file to your repository. This workflow definition file contains all relevant instructions for building the project on GitHub Actions.</p> <p>The following workflow file instructs GitHub Actions to build your Gradle project using the Gradle Wrapper, executed by the default Java distribution for GitHub Actions. Create a new file named <code>.github/workflows/build-gradle-project.yml</code> with the following content, and push it to the GitHub repository.</p> <pre><code>name: Build Gradle project\n\non:\n  push:\n\njobs:\n  build-gradle-project:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout project sources\n      uses: actions/checkout@v4\n\n    - name: Setup Gradle\n      uses: gradle/actions/setup-gradle@v3\n      with:\n        build-scan-publish: true\n        build-scan-terms-of-use-url: \"https://gradle.com/terms-of-service\"\n        build-scan-terms-of-use-agree: \"yes\"\n\n    - name: Run build\n      run: ./gradlew build\n</code></pre> <p>Gradle Build Scans\u00ae are a great way to view your build results and provide valuable insights into your build. The workflow is configured to automatically publish a Build Scan for each build, accepting the legal terms of use. If you don't wish to publish Build Scans, you can remove this configuration from the workflow.</p> <p>Commit the changes and push to the repository:</p> <pre><code>$ git add .\n$ git commit -m \"Add GitHub Actions workflow\"\n$ git push\n</code></pre>"},{"location":"ci/github-actions/#view-the-github-actions-results","title":"View the GitHub Actions results","text":"<p>Once this workflow file is pushed, you should immediately see the workflow execution in the GitHub Actions page for your repository (e.g., https://github.com/gradle/gradle/actions). Any subsequent push to the repository will trigger the workflow to run.</p>"},{"location":"ci/github-actions/#list-all-runs-of-the-github-actions-workflow","title":"List all runs of the GitHub Actions workflow","text":"<p>The main actions page can be used to list all runs for a GitHub Actions workflow.</p> <p></p>"},{"location":"ci/github-actions/#see-the-results-for-github-actions-workflow-run","title":"See the results for GitHub Actions workflow run","text":"<p>Clicking on the link for a workflow run will show the details of the workflow run, including a summary of all Gradle builds with links to any Build Scan published.</p> <p>TIP: Configuring build scans is especially helpful on cloud CI systems like GitHub Actions because it has additional environment and test results information that are difficult to obtain otherwise.</p> <p></p>"},{"location":"ci/github-actions/#view-the-details-for-jobs-and-steps-in-the-workflow","title":"View the details for Jobs and Steps in the workflow","text":"<p>Finally, you can view the logs for the individual workflow Jobs and each Step defined for a Job:</p> <p></p>"},{"location":"ci/github-actions/#enable-caching-of-downloaded-artifacts","title":"Enable caching of downloaded artifacts","text":"<p>The setup-gradle action used by this workflow will enable saving and restoring of the Gradle User Home directory in the built-in GitHub Actions cache. This will speed up your GitHub Actions build by avoiding the need to re-download Gradle versions and project dependencies, as well as re-using state from the previous workflow execution.</p> <p>Details about what entries are saved/restored from the cache can be viewed in the generated Job Summary:</p> <p></p>"},{"location":"ci/github-actions/#detect-vulnerable-dependencies-with-a-dependency-submission-workflow","title":"Detect vulnerable dependencies with a dependency-submission workflow","text":"<p>GitHub supply chain security features will detect and alert about any dependencies that have known vulnerabilities. In order to do this, GitHub requires a complete dependency graph for your project.</p> <p>NOTE: Ensure that you have both Dependency graph and Dependabot alerts enabled for your repository.</p> <p>The dependency-submission action for Gradle provides the simplest way to generate a dependency graph for your project. This action will attempt to detect and upload a list of all dependencies used by your build.</p> <p>We recommend a separate GitHub Actions workflow for dependency submission. Create a GitHub Actions workflow by adding a <code>.github/workflows/&lt;workflow-name&gt;.yml</code> file to your repository. Create a new file named <code>.github/workflows/gradle-dependency-submission.yml</code> with the following content, and push it to the GitHub repository.</p> <pre><code>name: Gradle Dependency Submission\n\non:\n  push:\n    branches:\n    - main\n\njobs:\n  dependency-submission:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout project sources\n      uses: actions/checkout@v4\n\n    - name: Generate and submit dependency graph\n      uses: gradle/actions/dependency-submission@v3\n      with:\n        build-scan-publish: true\n        build-scan-terms-of-use-url: \"https://gradle.com/terms-of-service\"\n        build-scan-terms-of-use-agree: \"yes\"\n</code></pre> <p>Gradle Build Scans\u00ae are a great way to view your build results and provide valuable insights into your build. The workflow is configured to automatically publish a Build Scan for each build, accepting the legal terms of use. If you don't wish to publish Build Scans, you can remove this configuration from the workflow.</p> <p>Commit the changes and push to the repository:</p> <pre><code>$ git add .\n$ git commit -m \"Add Dependency submission workflow\"\n$ git push\n</code></pre>"},{"location":"ci/github-actions/#viewing-the-dependency-graph","title":"Viewing the dependency graph","text":"<p>Once the dependency-submission workflow has completed, you can view all reported dependencies by navigating to <code>Insights -&gt; Dependency graph</code>.</p> <p>This image reveals that the repository contains a version of <code>com.google.guava:guava</code> with a moderate vulnerability.</p> <p></p>"},{"location":"ci/github-actions/#viewing-all-dependency-alerts","title":"Viewing all dependency alerts","text":"<p>You can view a list of all vulnerabilities by navigating to <code>Security -&gt; Dependabot</code>.</p> <p></p>"},{"location":"ci/gitlab-ci/","title":"GitLab CI","text":""},{"location":"ci/gitlab-ci/#executing-gradle-builds-on-gitlab-ci","title":"Executing Gradle builds on GitLab CI","text":"<p>Tip</p> <p>Top engineering teams using GitLab CI have been able to reduce CI build time by up to 90% by using the Gradle Build Cache. https://gradle.org/training/#build-cache-deep-dive[Register here] for our Build Cache training session to learn how your team can achieve similar results.</p> <p>Building Gradle projects doesn't stop with the developer's machine. https://en.wikipedia.org/wiki/Continuous_integration[Continuous Integration] (CI) has been a long-established practice for running a build for every single change committed to version control to tighten the feedback loop.</p> <p>In this guide, we'll discuss how to configure link:https://docs.gitlab.com/ee/ci/[GitLab CI] for a Gradle project hosted on GitLab (GitLab.com, self-managed or dedicated).</p>"},{"location":"ci/gitlab-ci/#introduction","title":"Introduction","text":"<p>GitLab CI is a cloud-based CI solution provider built directly into GitLab, making it an excellent choice for projects hosted on GitLab.</p>"},{"location":"ci/gitlab-ci/#what-youll-need","title":"What you'll need","text":"<ul> <li>A text editor</li> <li>A command prompt</li> <li>The Java Development Kit (JDK), version 1.8 or higher</li> <li>A local Gradle installation to initialize a new Gradle project</li> <li>A GitLab instance (any tier, any deployment type)</li> <li>A GitLab account on the instance you want to use</li> </ul>"},{"location":"ci/gitlab-ci/#setup-a-gradle-project-on-gitlab","title":"Setup a Gradle project on GitLab","text":"<p>If you have a Gradle project hosted on GitLab, you can skip this step and move directly to Configure GitLab CI</p> <p>If not, follow these steps to initialize a new Gradle project on GitLab.</p>"},{"location":"ci/gitlab-ci/#create-a-new-gitlab-repository-for-your-project","title":"Create a new GitLab repository for your project","text":"<p>Create a new repository named <code>gitlab-ci-gradle-sample</code> via the GitLab user interface.</p> <p></p>"},{"location":"ci/gitlab-ci/#clone-the-repository-locally","title":"Clone the repository locally","text":"<pre><code>$ git clone git@example.gitlab.com:&lt;YOUR-GITHUB-USER&gt;/gitlab-ci-gradle-sample.git\nCloning into 'gitlab-ci-gradle-sample'...\n$ cd gitlab-ci-gradle-sample\n</code></pre>"},{"location":"ci/gitlab-ci/#initialize-the-gradle-project-and-commit-to-the-repository","title":"Initialize the Gradle project and commit to the repository","text":"<p>Use <code>gradle init</code> to create a fresh Gradle project. You can choose any available options during <code>init</code>, but we recommend choosing \"library\" as the project type.</p> <p>Once the project is generated, commit the changes and push to the repository.</p> <pre><code>$ gradle init\n$ git add .\n$ git commit -m \"Initial commit\"\n$ git push\n</code></pre>"},{"location":"ci/gitlab-ci/#enable-build-scantm-publishing","title":"Enable Build Scan\u2122 publishing","text":"<p>Gradle Build Scans are a great way to view your build results and provide valuable insights into your build. To publish Build Scans from GitLab CI, you'll need to pre-approve the Terms &amp; Conditions.</p> <p>To do so, add the following content to the top of your <code>settings.gradle[.kts]</code> file. GitLab CI sets the \"CI\" environment variable:</p> <pre><code>plugins {\n    id(\"com.gradle.enterprise\") version(\"3.16.2\")\n}\n\ngradleEnterprise {\n    if (System.getenv(\"CI\") != null) {\n        buildScan {\n            publishAlways()\n            termsOfServiceUrl = \"https://gradle.com/terms-of-service\"\n            termsOfServiceAgree = \"yes\"\n        }\n    }\n}\n</code></pre>"},{"location":"ci/gitlab-ci/#test-building-the-project","title":"Test building the project","text":"<p>The project uses the Gradle Wrapper for building the project. It is a recommended practice for any Gradle project as it enables your project to build on CI without installing the Gradle runtime.</p> <p>Before asking GitLab CI to build your project, it's useful to ensure that it builds locally. Adding the \"CI\" environment variable will emulate running the build on GitLab CI.</p> <p>The following command achieves that:</p> <pre><code>$ CI=true ./gradlew build\n\nBUILD SUCCESSFUL\n\nPublishing build scan...\nhttps://gradle.com/s/7mtynxxmesdio\n</code></pre> <p>If the build works as expected, commit the changes and push to the repository.</p> <pre><code>$ git commit -a -m \"Publish Build Scans from GitLab CI\"\n$ git push\n</code></pre>"},{"location":"ci/gitlab-ci/#configure-gitlab-ci","title":"Configure GitLab CI","text":"<p>You can create a GitLab CI pipeline by adding a <code>.gitlab-ci.yml</code> file to your repository. This pipeline definition file contains all relevant instructions for building the project on Gitlab CI.</p> <p>The following workflow file instructs GitLab CI to build your Gradle project using the Gradle Wrapper, executed by the Eclipse Temurin JDK. Create a new file named <code>.gitlab-ci.yml</code> with the following content, and push it to the GitLab repository.</p> <pre><code>build-gradle-project:\n  image: eclipse-temurin:latest\n\n  script:\n    - ./gradlew build\n\n  artifacts:\n    reports:\n      junit: '**/build/test-results/**/TEST-*.xml'\n</code></pre> <p>This file defines a single job that executes the <code>./gradlew build</code> command.</p> <ul> <li>The <code>image</code> field defines which Docker image the job will run in. Thanks to the Gradle Wrapper, only a JDK is necessary.</li> <li>The <code>artifacts</code> field defines files generated by the job that GitLab CI should save. In particular, saving the JUnit report generated by the Gradle test tasks allows test results to be displayed directly in the Merge Request or Pipeline pages.</li> </ul> <p>Commit the changes and push them to the repository:</p> <pre><code>$ git add .\n$ git commit -m \"Add GitLab CI pipeline\"\n$ git push\n</code></pre>"},{"location":"ci/gitlab-ci/#view-the-gitlab-ci-results","title":"View the GitLab CI results","text":"<p>Once this pipeline file is pushed, you should immediately see the pipeline execution in the GitLab CI page for your repository (e.g., <code>https://gitlab.com/username/repository/-/pipelines</code>). Any subsequent push to the repository will trigger the pipeline to run.</p>"},{"location":"ci/gitlab-ci/#enable-caching","title":"Enable caching","text":"<p>By default, no files are persisted between CI runs, so each job must download all dependencies again. We can configure GitLab to cache some files between jobs. This is especially efficient when running your own GitLab CI runner, as the cache is stored locally on the runner.</p> <p>CAUTION: The publicly available shared runners store their cache in a remote location. As the cache grows, downloading the cache archive, extracting it, and uploading it again at the end of the job may take more time than not using any cache. For this reason, we recommend only caching the Gradle Wrapper. For caching everything else, see configuring a Gradle Remote Build Cache.</p> <p>To reuse some files between jobs, add the following configuration to your existing jobs:</p> <pre><code>build-gradle-project:\n  # \u2026existing configuration\u2026\n\n  variables:\n    GRADLE_USER_HOME: $CI_PROJECT_DIR/.gradle\n\n  cache:\n    paths:\n      - .gradle/wrapper\n    key:\n      files:\n        - gradle/wrapper/gradle-wrapper.properties\n</code></pre> <p>Commit the changes and push to the repository:</p> <pre><code>$ git add .\n$ git commit -m \"Cache the Gradle Wrapper between CI jobs\"\n$ git push\n</code></pre>"},{"location":"ci/gitlab-ci/#further-reading","title":"Further reading","text":"<p>Learn more about building Gradle projects with GitLab CI:</p> <ul> <li>GitLab CI documentation</li> <li>.gitlab-ci.yml syntax reference</li> <li>Predefined variables</li> <li>Avoiding duplication between multiple jobs</li> </ul>"},{"location":"ci/gitlab-ci/#summary","title":"Summary","text":"<p>Setting up and configuring Gradle builds on CI is straightforward, requiring just a few steps. The benefit of receiving fast feedback clearly speaks for itself. GitLab CI offers a simple and convenient mechanism to set up CI for any Gradle project hosted on GitLab.</p>"},{"location":"ci/jenkins/","title":"Jenkins","text":""},{"location":"ci/jenkins/#executing-gradle-builds-on-jenkins","title":"Executing Gradle builds on Jenkins","text":"<p>Tip</p> <p>Top engineering teams using Jenkins have been able to reduce CI build time by up to 90% by using the Gradle Build Cache. Register here for our Build Cache training session to learn how your team can achieve similar results.</p> <p>Building Gradle projects doesn't stop with the developer's machine. Continuous Integration (CI) has been a long-established practice for running a build for every single change committed to version control to tighten the feedback loop.</p> <p>In this guide, we'll discuss how to configure Jenkins for a typical Gradle project.</p>"},{"location":"ci/jenkins/#what-youll-need","title":"What you'll need","text":"<ul> <li>A text editor</li> <li>A command prompt</li> <li>The Java Development Kit (JDK), version 1.7 or higher</li> <li>A Jenkins installation (setup steps explained in this post)</li> </ul>"},{"location":"ci/jenkins/#setup-a-typical-project","title":"Setup a typical project","text":"<p>As an example, this guide is going to focus on a Java-based project. More specifically, a Gradle plugin written in Java and tested with Spek. First, we'll get the project set up on your local machine before covering the same steps on CI.</p> <p>Just follow these steps:</p>"},{"location":"ci/jenkins/#clone-the-gradle-site-plugin-repository","title":"Clone the Gradle Site Plugin repository","text":"<pre><code>$ git clone https://github.com/gradle/gradle-site-plugin.git\nCloning into 'gradle-site-plugin'...\n$ cd gradle-site-plugin\n</code></pre>"},{"location":"ci/jenkins/#build-the-project","title":"Build the project","text":"<p>As a developer of a Java project, you'll typically want to compile the source code, run the tests, and assemble the JAR artifact. That's no different for Gradle plugins. The following command achieves exactly that:</p> <pre><code>$ ./gradlew build\n\nBUILD SUCCESSFUL\n14 actionable tasks: 14 executed\n</code></pre> <p>The project provides the Gradle Wrapper as part of the repository. It is a recommended practice for any Gradle project as it enables your project to be built on CI without having to install the Gradle runtime.</p>"},{"location":"ci/jenkins/#build-scan-integration","title":"Build scan integration","text":"<p>The sample project is equipped with support for generating build scans. Running the build with the command line option <code>--scan</code> renders a link in the console.</p> <pre><code>$ ./gradlew build --scan\n\nPublishing build scan...\nhttps://gradle.com/s/7mtynxxmesdio\n</code></pre> <p>The following section will describe how to build the project with the help of Jenkins.</p>"},{"location":"ci/jenkins/#setup-jenkins","title":"Setup Jenkins","text":"<p>Jenkins is one of the most prominent players in the field. In the course of this section, you'll learn how to set up Jenkins, configure a job to pull the source code from GitHub, and run the Gradle build.</p>"},{"location":"ci/jenkins/#install-and-start-jenkins","title":"Install and start Jenkins","text":"<p>On the Jenkins website, you can pick from a variety of distributions. This post uses the runnable WAR file. A simple Java command brings up the Jenkins server.</p> <pre><code>$ wget https://mirrors.jenkins.io/war-stable/latest/jenkins.war\n$ java -jar jenkins.war\n</code></pre> <p>In the browser, navigate to <code>localhost</code> with port <code>8080</code> to render the Jenkins dashboard. You will be asked to set up a new administration user and which plugins to install.</p>"},{"location":"ci/jenkins/#installation-of-plugins","title":"Installation of plugins","text":"<p>Confirm to install the recommended plugins when starting Jenkins for the first time. Under \"Manage Jenkins &gt; Manage Plugins,\" ensure that you have the following two plugins installed:</p> <ul> <li>Git plugin</li> <li>Gradle plugin</li> </ul> <p>Next, we can set up the job for building the project.</p>"},{"location":"ci/jenkins/#create-a-jenkins-job","title":"Create a Jenkins job","text":"<p>Setting up a new Gradle job can be achieved with just a couple of clicks. From the left navigation bar, select \"New Item &gt; Freestyle project\". Enter a new name for the project. We'll pick \"gradle-site-plugin\" for the project.</p> <p>Select the radio button \"Git\" in the section \"Source Code Management\". Enter the URL of the GitHub repository: <code>https://github.com/gradle/gradle-site-plugin.git</code>.</p> <p></p> <p>Furthermore, create a \"Build step\" in the section \"Build\" by selecting \"Invoke Gradle script\". As mentioned before, we'll want to use the Wrapper to execute the build. In the \"Tasks\" input box, enter <code>build</code> and use the \"Switches\" <code>--scan -s</code> to generate a build scan and render a stack trace in case of a build failure.</p> <p></p>"},{"location":"ci/jenkins/#execute-the-job","title":"Execute the job","text":"<p>Save the configuration of the job and execute an initial build by triggering the \"Build Now\" button. The build should finish successfully and render a \"Gradle Build Scan\" icon that brings you directly to the build scan for the given build.</p> <p></p> <p>There are various options to trigger Jenkins builds continuously: from polling the repository periodically, to building on a set schedule, or via callback URL.</p>"},{"location":"ci/jenkins/#further-reading","title":"Further reading","text":"<p>You can learn more about advanced Jenkins usage through these resources:</p> <ul> <li>Using credentials with Jenkins</li> <li>Pipeline as code with Jenkins</li> <li>Modeling a Continuous Deployment pipeline for a Spring Boot application</li> </ul>"},{"location":"ci/jenkins/#summary","title":"Summary","text":"<p>Executing Gradle builds on CI can be set up and configured with just a handful of steps. The benefit of receiving fast feedback clearly speaks for itself. If you are not using Jenkins, no problem, many CI products tightly integrate with Gradle as a first-class citizen.</p>"},{"location":"ci/teamcity/","title":"TeamCity","text":""},{"location":"ci/teamcity/#executing-gradle-builds-on-teamcity","title":"Executing Gradle builds on TeamCity","text":"<p>Tip</p> <p>Top engineering teams using TeamCity have been able to reduce CI build time by up to 90% by using the Gradle Build Cache. Register here for our Build Cache training session to learn how your team can achieve similar results.</p> <p>Building Gradle projects doesn't stop with the developer's machine. Continuous Integration (CI) has been a long-established practice for running a build for every single change committed to version control to tighten the feedback loop.</p> <p>In this guide, we'll discuss how to configure TeamCity for a typical Gradle project.</p>"},{"location":"ci/teamcity/#what-youll-need","title":"What you'll need","text":"<ul> <li>A command prompt</li> <li>The Java Development Kit (JDK), version 1.8 or higher</li> <li>A TeamCity installation (setup steps explained in this guide)</li> </ul>"},{"location":"ci/teamcity/#setup-a-typical-project","title":"Setup a typical project","text":"<p>For demonstration purposes, this guide is going to focus on building a Java-based project; however, this setup will work with any Gradle-compatible project. More specifically, a Gradle plugin written in Java and tested with Spek. First, we'll get the project set up on your local machine before covering the same steps on CI.</p> <p>Just follow these steps:</p>"},{"location":"ci/teamcity/#clone-the-gradle-site-plugin-repository","title":"Clone the Gradle Site Plugin repository","text":"<pre><code>$ git clone https://github.com/gradle/gradle-site-plugin.git\nCloning into 'gradle-site-plugin'...\n$ cd gradle-site-plugin\n</code></pre>"},{"location":"ci/teamcity/#build-the-project","title":"Build the project","text":"<p>As a developer of a Java project, you'll typically want to compile the source code, run the tests, and assemble the JAR artifact. That's no different for Gradle plugins. The following command achieves exactly that:</p> <pre><code>$ ./gradlew build\n\nBUILD SUCCESSFUL\n14 actionable tasks: 14 executed\n</code></pre> <p>The project provides the Gradle Wrapper as part of the repository. It is a recommended practice for any Gradle project as it enables your project to be built on CI without having to install the Gradle runtime.</p>"},{"location":"ci/teamcity/#build-scan-integration","title":"Build scan integration","text":"<p>The sample project is equipped with support for generating build scans. Running the build with the command line option <code>--scan</code> renders a link in the console.</p> <pre><code>$ ./gradlew build --scan\nPublishing build scan...\nhttps://gradle.com/s/7mtynxxmesdio\n</code></pre>"},{"location":"ci/teamcity/#setup-teamcity","title":"Setup TeamCity","text":"<p>JetBrains TeamCity is a powerful and user-friendly Continuous Integration and Deployment server that works out of the box. JetBrains offers several licensing options that allow you to scale TeamCity to your needs. In this setup, we'll use TeamCity Professional, a free fully functional edition suitable for average projects. In the course of this section, you'll learn how to set up TeamCity, create a build configuration to pull the source code from GitHub, and run the Gradle build.</p>"},{"location":"ci/teamcity/#install-and-start-teamcity","title":"Install and start TeamCity","text":"<p>On the TeamCity website, you can pick from a variety of distributions. This post uses TeamCity bundled with Tomcat servlet container and covers the evaluation setup of a TeamCity server and a default build agent running on the same machine.</p> <ol> <li>Make sure you have JRE or JDK installed and the JAVA_HOME environment variable is pointing to the Java installation directory. Oracle Java 1.8 JDK is required.</li> <li> <p>Download TeamCity .tar.gz distribution. Unpack the <code>TeamCity&lt;version number&gt;.tar.gz</code> archive, for example, using the WinZip, WinRar or a similar utility under Windows, or the following command under Linux or macOS:</p> <pre><code>tar xfz TeamCity&lt;version number&gt;.tar.gz\n</code></pre> </li> <li> <p>Start the TeamCity server and one default agent at the same time, using the runAll script provided in the <code>&lt;TeamCity home&gt;/bin</code> directory, e.g.</p> <pre><code>runAll.sh start\n</code></pre> </li> <li> <p>To access the TeamCity Web UI, navigate to <code>http://localhost:8111/</code>. Follow the defaults of the TeamCity setup. You will be asked to set up a new administration user.</p> </li> </ol> <p>Next, we can set up the project and run a build in TeamCity.</p>"},{"location":"ci/teamcity/#create-a-teamcity-build","title":"Create a TeamCity build","text":"<p>Setting up a new Gradle build in TeamCity requires just a few clicks: TeamCity comes bundled with a Gradle plugin, so you do not need to install plugins additionally. However, it is recommended that you install the TeamCity Build Scan plugin.</p> <p>On the Administration | Projects page click Create project, use the option From the repository URL and enter the URL of the GitHub repository: <code>https://github.com/gradle/gradle-site-plugin.git</code>.</p> <p></p> <p>Follow the Create Project wizard, it will prompt for the project and build configuration name and automatically detect build steps. Select the automatically Gradle build step and click Use selected:</p> <p></p> <p>The build step is added to the build configuration:</p> <p></p> <p>Click Edit, on the page that opens click Advanced options. Using the Wrapper to execute the build is considered good practice with Gradle, and on automatic detection, this option is selected by default. We\u2019ll want to generate a build scan, so we\u2019ll enter the <code>--scan</code> option in Additional Gradle command line parameters field.</p> <p></p> <p>Save the settings and we\u2019re ready to run the build.</p>"},{"location":"ci/teamcity/#run-the-build-in-teamcity","title":"Run the build in TeamCity","text":"<p>Click the Run button in the top right corner:</p> <p></p> <p>TeamCity will start the build and you\u2019ll be able to view the build progress by clicking Build Configuration Home. When the build is finished, you can review the build results by clicking the build number link:</p> <p></p> <p>You can view the tests right here in TeamCity:</p> <p></p> <p>The information on parameters and environment of the build is available on the Parameters tab of the build results.</p> <p>If you installed the TeamCity Build Scan plugin, you will see a link to the build scan in the Build Results view:</p> <p></p> <p>Otherwise, the link to the build scan for the given build is available in the build log:</p> <p></p> <p>There are various options to trigger TeamCity builds continuously: from polling the repository periodically, to building on a set schedule, or via post-commit hook.</p>"},{"location":"ci/teamcity/#further-reading","title":"Further reading","text":"<p>You can learn more about advanced TeamCity usage through these resources:</p> <ul> <li>Build chains and dependencies</li> <li>Remote run and pre-tested commit</li> </ul> <p>More information is available in TeamCity documentation. Follow the TeamCity blog for the latest news.</p>"},{"location":"ci/teamcity/#summary","title":"Summary","text":"<p>Executing Gradle builds on CI can be set up and configured with just a handful of steps. The benefit of receiving fast feedback clearly speaks for itself. If you are not using TeamCity, no problem, many CI products tightly integrate with Gradle as a first-class citizen.</p>"},{"location":"ci/travis-ci/","title":"Travis CI","text":""},{"location":"ci/travis-ci/#executing-gradle-builds-on-travis-ci","title":"Executing Gradle builds on Travis CI","text":"<p>Tip</p> <p>Top engineering teams using Travis CI have been able to reduce CI build time by up to 90% by using the Gradle Build Cache. Register here for our Build Cache training session to learn how your team can achieve similar results.</p> <p>Building Gradle projects doesn't stop with the developer's machine. Continuous Integration (CI) has been a long-established practice for running a build for every single change committed to version control to tighten the feedback loop.</p> <p>In this guide, we'll discuss how to configure Travis CI for a typical Gradle project.</p>"},{"location":"ci/travis-ci/#what-youll-need","title":"What you'll need","text":"<ul> <li>A text editor</li> <li>A command prompt</li> <li>The Java Development Kit (JDK), version 1.8 or higher</li> </ul>"},{"location":"ci/travis-ci/#setup-a-typical-project","title":"Setup a typical project","text":"<p>As example, this guide is going to focus on a Java-based project. More specifically, a Gradle plugin written in Java and tested with Spek. First, we'll get the project set up on your local machine before covering the same steps on CI.</p> <p>Just follow these steps:</p>"},{"location":"ci/travis-ci/#clone-the-gradle-site-plugin-repository","title":"Clone the Gradle Site Plugin repository","text":"<pre><code>$ git clone https://github.com/gradle/gradle-site-plugin.git\nCloning into 'gradle-site-plugin'...\n$ cd gradle-site-plugin\n</code></pre>"},{"location":"ci/travis-ci/#build-the-project","title":"Build the project","text":"<p>As a developer of a Java project, you'll typically want to compile the source code, run the tests and assemble the JAR artifact. That's no different for Gradle plugins. The following command achieves exactly that:</p> <pre><code>$ ./gradlew build\n\nBUILD SUCCESSFUL\n14 actionable tasks: 14 executed\n</code></pre> <p>The project provides the Gradle Wrapper as part of the repository. It is a recommended practice for any Gradle project as it enables your project to be built on CI without having to install the Gradle runtime.</p>"},{"location":"ci/travis-ci/#build-scan-integration","title":"Build scan integration","text":"<p>The sample project is equipped with support for generating build scans. Running the build with the command line option <code>--scan</code> renders a link in the console.</p> <pre><code>$ ./gradlew build --scan\nPublishing build scan...\nhttps://gradle.com/s/7mtynxxmesdio\n</code></pre> <p>The following section will describe how to build the project with the help of Travis CI.</p>"},{"location":"ci/travis-ci/#configure-travis-ci","title":"Configure Travis CI","text":"<p>Travis CI is a free, cloud-based CI solution provider making it an excellent choice for open source projects. You can build any project as long as it is hosted on GitHub as a public repository. Travis CI does not provide built-in options to post-process produced artifacts of the build (e.g., host the JAR file or the HTML test reports). You will have to use external services (like S3) to transfer the files.</p>"},{"location":"ci/travis-ci/#create-the-configuration-file","title":"Create the configuration file","text":"<p>Travis CI requires you to check in a configuration file with your source code named <code>.travis.yml</code>. This file contains all relevant instructions for building the project.</p> <p>The following configuration file tells Travis CI to build a Java project with JDK 8, skip the usual default execution step, and run the Gradle build with the Wrapper.</p> <pre><code>language: java\ninstall: skip\n\nos: linux\ndist: trusty\njdk: oraclejdk8\n\nscript:\n  - ./gradlew build --scan -s\n</code></pre> <p>Select the project from the Travis CI profile. After activating the repository from the dashboard, the project is ready to be built with every single commit.</p> <p></p> <p>NOTE: Configuring build scans is especially helpful on cloud CI systems like Travis CI because it has additional environment and test results information that are difficult to obtain otherwise.</p>"},{"location":"ci/travis-ci/#enable-caching-of-downloaded-artifacts","title":"Enable caching of downloaded artifacts","text":"<p>Gradle's dependency management mechanism resolves declared modules and their corresponding artifacts from a binary repository. Once downloaded, the files will be re-used from the cache. You need to tell Travis CI explicitly that you want to store and use the Gradle cache and Wrapper for successive invocations of the build.</p> <pre><code>before_cache:\n  - rm -f $HOME/.gradle/caches/modules-2/modules-2.lock\n  - rm -fr $HOME/.gradle/caches/*/plugin-resolution/\n\ncache:\n  directories:\n    - $HOME/.gradle/caches/\n    - $HOME/.gradle/wrapper/\n</code></pre>"},{"location":"ci/travis-ci/#further-reading","title":"Further reading","text":"<p>You can learn more about advanced Travis CI usage through these resources:</p> <ul> <li>Encrypting sensitive data</li> <li>Modelling a pipeline with build stages</li> </ul>"},{"location":"ci/travis-ci/#summary","title":"Summary","text":"<p>Executing Gradle builds on CI can be set up and configured with just a handful of steps. The benefit of receiving fast feedback clearly speaks for itself. If you are not using Travis CI, no problem, many CI products tightly integrate with Gradle as a first-class citizen.</p>"},{"location":"kotlin/","title":"Gradle for Kotlin","text":""},{"location":"kotlin/#gradle-for-kotlin","title":"Gradle for Kotlin","text":"<p>Gradle is one of the most popular build tools in the Kotlin space, including classic applications, Kotlin Multiplatform, and Android.</p>"},{"location":"kotlin/#official-documentation","title":"Official Documentation","text":"<p>The official documentation for Kotlin development with Gradle is provided by the Kotlin Foundation on its site. You can find this documentation here.</p>"},{"location":"kotlin/#featured-recipes","title":"Featured Recipes","text":"<p>Info</p> <p>Work in progress, recipe contributions are welcome!</p>"},{"location":"kotlin/#references","title":"References","text":"<ul> <li>Gradle &amp; Kotlin Documentation by the Kotlin Foundation</li> </ul>"},{"location":"plugin-development/","title":"Summary","text":""},{"location":"plugin-development/#gradle-for-plugin-development","title":"Gradle for Plugin Development","text":""},{"location":"plugin-development/#recipes","title":"Recipes","text":"<ul> <li>Writing Gradle plugins in Kotlin</li> </ul>"},{"location":"plugin-development/kotlin-plugins/","title":"Kotlin plugin development","text":""},{"location":"plugin-development/kotlin-plugins/#writing-gradle-plugins-in-kotlin","title":"Writing Gradle plugins in Kotlin","text":"<p>Kotlin has a great Java interoperability story, making it a good language to write Gradle plugins.</p> <p>For complete compatibility, several aspects require extra care. This page gives an overview of the different compatibility issues and recommended setup to avoid them.   </p>"},{"location":"plugin-development/kotlin-plugins/#gradle-compatibility","title":"Gradle compatibility","text":"<p>When executing a build, Gradle forces its own version of <code>kotlin-stdlib</code>, the embedded version. </p> <p>For this reason, your plugin must depend on a version of <code>kotlin-stdlib</code> that is compatible with the embedded version.</p> <p>Gradle publishes the embedded versions in the Kotlin compatibility matrix.</p> <p>For an example, at the time of writing, Gradle 8.10 embeds <code>kotlin-stdlib:1.9.24</code>.</p>"},{"location":"plugin-development/kotlin-plugins/#making-your-code-compatible-with-the-kotlin-embedded-version","title":"Making your code compatible with the Kotlin embedded version","text":"<p>You can use a more recent version of the Kotlin Gradle Plugin, but you'll have to make sure not to call any 2.0 API:</p> <pre><code>plugins {\n  // Use latest version of the Kotlin Gradle Plugin\n  id(\"org.jetbrains.kotlin.jvm\").version(\"2.0.21\")\n  // java-gradle-plugin creates marker publications and plugin descriptors \n  id(\"java-gradle-plugin\")\n}\n\ntasks.withType&lt;KotlinCompile&gt;().configureEach {\n  // But make sure your plugin code only uses 1.9 APIs\n  compilerOptions.apiVersion.set(KotlinVersion.KOTLIN_1_9)\n}\n\nkotlin {\n  // Also make sure to depend on 1.9 kotlin-stdlib\n  // See also https://youtrack.jetbrains.com/issue/KT-53462\n  coreLibrariesVersion = \"1.9.24\"\n}\n</code></pre>"},{"location":"plugin-development/kotlin-plugins/#ensuring-dependencies-are-compatible-with-the-kotlin-embedded-version","title":"Ensuring dependencies are compatible with the Kotlin embedded version","text":"<p>In addition to your own code, your dependencies must also use a compatible version of <code>kotlin-stdlib</code>.</p> <p>Because the compiler doesn't run on dependencies, <code>apiVersion</code> does not help here, you'll have to check that the dependencies do not depend on a newer version of <code>kotlin-stdlib</code>.</p> <p>This can be done using a custom Gradle task:</p> <pre><code>/**\n * An example of a task that checks that no kotlin-stdlib &gt; 1.9.24 is pulled\n * in the classpath.\n * Configuration cache and edge cases are left as an exercise to the reader.\n */\ntasks.register(\"checkGradleCompatibility\") {\n  doLast {\n    val root = configurations.getByName(\"runtimeClasspath\").incoming.resolutionResult.rootComponent.get()\n    root.dependencies.forEach {\n      if (it is ResolvedDependencyResult) {\n        val rdr = it\n        val requested = rdr.requested\n        val selected = rdr.selected\n        if (\n          requested is ModuleComponentSelector\n          &amp;&amp; requested.group == \"org.jetbrains.kotlin\"\n          &amp;&amp; requested.module == \"kotlin-stdlib\"\n        ) {\n\n          val requestedVersion = requested.version\n          val selectedVersion = selected.moduleVersion?.version\n          check (selectedVersion == requestedVersion) {\n            \"kotlin-stdlib was upgraded to $selectedVersion\"\n          }\n        }\n      }\n    }\n  }\n} \n</code></pre>"},{"location":"plugin-development/kotlin-plugins/#alternative-1-relocating-kotlin-stdlib","title":"Alternative #1: relocating kotlin-stdlib","text":"<p>If the steps above are too complicated, maybe because a required dependency uses a newer version of Kotlin, or because your own plugin code requires newer Kotlin features, you can shadow a relocated version of <code>kotlin-stdlib</code> that doesn't clash with the Gradle embedded one.</p> <p>To do this, you can use R8. You can read more about the process in this dedicated blog post. </p> <p>Note</p> <p>Shadow could be an alternative, but we have found that it doesn't work reliably because it relocates String constants as well</p>"},{"location":"plugin-development/kotlin-plugins/#alternative-2-using-separate-classloaders","title":"Alternative #2: using separate classloaders","text":"<p>Another solution if you want to use a newer <code>kotlin-stdlib</code> without using relocation is to run your code in a separate, isolated, classloader. The glue code of your plugin and initialization still has to be compatible but as soon as you switch to a new classloader, you can use any dependencies without any risk of incompatibilities.</p> <p>Projects such as Gratatouille can help with that.</p>"},{"location":"plugin-development/kotlin-plugins/#groovy-interoperability","title":"Groovy interoperability","text":"<p>Because your plugin may be used from Groovy build scripts (<code>build.gradle</code>), it is important to have Groovy compatibility in mind.</p>"},{"location":"plugin-development/kotlin-plugins/#general-interoperability","title":"General interoperability","text":"<p>In general Groovy does not know anything about Kotlin. Avoid Kotlin-only features such as:</p> <ul> <li>extension functions</li> <li>default parameter values</li> <li>function types</li> <li>receivers</li> <li>etc... </li> </ul> <p>These features may be used in extra functionality for Kotlin callers, but it is important that all the base functionality of your plugin does not require them.</p>"},{"location":"plugin-development/kotlin-plugins/#closures","title":"Closures","text":"<p>Closure are an important piece of the Groovy build scripts. Every block is a closure under the hood.</p> <p>Because dealing with Groovy closure from Kotlin (and Java) is cumbersome, Gradle allows to use <code>Action&lt;T&gt;</code> instead. For all types instantiated by Gradle (tasks, extensions, newInstance(), etc..), the Gradle runtime decorates all functions with a single <code>Action&lt;T&gt;</code> parameter with an matching function accepting a closure (doc).</p> <p>For an example, the Kotlin code below:</p> <pre><code>open class MyExtension {\n  fun doStuff(action: Action&lt;Spec&gt;) {\n    // ...\n  }\n} \n</code></pre> <p>can be called from groovy with a closure:</p> <pre><code>myExtension {\n  doStuff {\n    // This is a closure even though groovy doesn't know about Action  \n    // ...  \n  }\n} \n</code></pre>"},{"location":"plugin-development/kotlin-plugins/#difference-with-buildgradlekts-scripts","title":"Difference with <code>build.gradle.kts</code> scripts","text":"<p>If you are used to writing <code>build.gradle.kts</code> files, you may use the <code>kotlin-dsl</code> Gradle plugin to write your plugins.</p> <p><code>kotlin-dsl</code> configures the Kotlin compiler so that you can use precompiled scripts plugins and/or write similar syntax in your regular <code>.kt</code> files.</p> <p>The <code>kotlin-dls</code> plugin:</p> <ul> <li>applies <code>\"java-gradle-plugin\"</code>.</li> <li>applies <code>kotlin-embedded</code> to use the same Kotlin embedded version as your Gradle distribution. </li> <li>applies the <code>\"kotlin-dsl-precompiled-script-plugins\"</code> allowing to use <code>build.gradle.kts</code> files.</li> <li>adds <code>gradleKotlinDsl()</code> to the <code>compileOnly</code> configuration.</li> <li>configures the <code>sam-with-receiver</code> Kotlin compiler plugin to transform <code>it.</code> usages into <code>this.</code>.</li> <li>configures the <code>kotlin-assignment</code> Kotlin compiler plugin to allow setting <code>Property</code> with the <code>=</code> operator.</li> <li>sets Kotlin <code>apiVersion</code> and <code>languageVersion</code> according to Gradle compatibility matrix. </li> <li>adds the <code>-Xsam-conversions=class</code> compiler option.</li> <li>adds others compiler options for compatibility:<ul> <li><code>-java-parameters</code> to support Java 8 Parameter class and getting method parameters through reflection</li> <li><code>-Xjvm-default=all</code> to add link: Default methods in interfaces</li> <li><code>-Xjsr305=strict</code> for increased null safety</li> </ul> </li> </ul> <p>This is a significant departure from the baseline Kotlin configuration so be aware of the trade-offs when using <code>kotlin-dsl</code>. </p> <p>Also, <code>kotlin-dsl</code> targets the Kotlin embedded version of your current distribution. If you want to be compatible with lower versions of Gradle, using the <code>com.jetbrains.kotlin.jvm</code> plugin provides more flexibility.</p>"},{"location":"troubleshooting/","title":"Troubleshooting Gradle","text":""},{"location":"troubleshooting/#troubleshooting-gradle","title":"Troubleshooting Gradle","text":"<p>Tools, tips and tricks for troubleshooting issues with Gradle.</p> <p>Info</p> <p>Work in progress, recipe contributions are welcome!</p>"},{"location":"troubleshooting/#references","title":"References","text":"<ul> <li>Official Troubleshooting Guide</li> </ul>"}]}